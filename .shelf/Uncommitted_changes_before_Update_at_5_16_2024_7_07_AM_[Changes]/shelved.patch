Index: src/main/java/net/minusmc/minusbounce/features/module/modules/combat/KillAura.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * MinusBounce Hacked Client\r\n * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.\r\n * https://github.com/MinusMC/MinusBounce\r\n */\r\npackage net.minusmc.minusbounce.features.module.modules.combat\r\n\r\nimport net.minecraft.entity.Entity\r\nimport net.minecraft.entity.EntityLivingBase\r\nimport net.minecraft.entity.item.EntityArmorStand\r\nimport net.minecraft.item.ItemSword\r\nimport net.minecraft.network.play.client.C07PacketPlayerDigging\r\nimport net.minecraft.network.play.client.C08PacketPlayerBlockPlacement\r\nimport net.minecraft.network.play.client.C0APacketAnimation\r\nimport net.minecraft.util.BlockPos\r\nimport net.minecraft.util.EnumFacing\r\nimport net.minecraft.util.MovingObjectPosition\r\nimport net.minecraft.util.Vec3\r\nimport net.minusmc.minusbounce.event.*\r\nimport net.minusmc.minusbounce.features.module.Module\r\nimport net.minusmc.minusbounce.features.module.ModuleCategory\r\nimport net.minusmc.minusbounce.features.module.ModuleInfo\r\nimport net.minusmc.minusbounce.features.module.modules.combat.killaura.KillAuraBlocking\r\nimport net.minusmc.minusbounce.utils.ClassUtils\r\nimport net.minusmc.minusbounce.utils.EntityUtils.isSelected\r\nimport net.minusmc.minusbounce.utils.RaycastUtils\r\nimport net.minusmc.minusbounce.utils.RaycastUtils.runWithModifiedRaycastResult\r\nimport net.minusmc.minusbounce.utils.Rotation\r\nimport net.minusmc.minusbounce.utils.extensions.*\r\nimport net.minusmc.minusbounce.utils.misc.RandomUtils\r\nimport net.minusmc.minusbounce.utils.player.MovementCorrection\r\nimport net.minusmc.minusbounce.utils.player.RotationUtils\r\nimport net.minusmc.minusbounce.utils.timer.MSTimer\r\nimport net.minusmc.minusbounce.value.*\r\nimport org.lwjgl.input.Keyboard\r\nimport org.lwjgl.opengl.GL11\r\nimport kotlin.math.cos\r\nimport kotlin.math.min\r\nimport kotlin.math.pow\r\nimport kotlin.math.sin\r\n\r\n\r\n@ModuleInfo(name = \"KillAura\", spacedName = \"Kill Aura\", description = \"Automatically attacks targets around you.\", category = ModuleCategory.COMBAT, keyBind = Keyboard.KEY_R)\r\nclass KillAura : Module() {\r\n    private val blockingModes = ClassUtils.resolvePackage(\"${this.javaClass.`package`.name}.killaura.blocking\", KillAuraBlocking::class.java)\r\n        .map { it.newInstance() as KillAuraBlocking }\r\n        .sortedBy { it.modeName }\r\n\r\n    private val blockingMode: KillAuraBlocking\r\n        get() = blockingModes.find { autoBlockModeValue.get().equals(it.modeName, true) } ?: throw NullPointerException()\r\n\r\n    private val cps = IntRangeValue(\"CPS\", 5, 8, 1, 20)\r\n    private val hurtTimeValue = IntegerValue(\"HurtTime\", 10, 0, 10)\r\n\r\n    val rangeValue = FloatValue(\"Range\", 3.7f, 1f, 8f, \"m\")\r\n    private val throughWallsValue = BoolValue(\"ThroughWalls\", true)\r\n    private val throughWallsRangeValue = object: FloatValue(\"ThroughWallsRange\", 2f, 1f, 8f, {throughWallsValue.get()}) {\r\n        override fun onChange(oldValue: Float, newValue: Float) {\r\n            val range = rangeValue.get()\r\n            if (newValue > range) set(range)\r\n        }\r\n\r\n        override fun onChanged(oldValue: Float, newValue: Float) {\r\n            val range = rangeValue.get()\r\n            if (newValue > range) set(range)\r\n        }\r\n    }\r\n\r\n    private val rotationValue = ListValue(\"RotationMode\", arrayOf(\"Vanilla\", \"BackTrack\", \"Grim\", \"Intave\", \"None\"), \"BackTrack\")\r\n    private val intaveRandomAmount = FloatValue(\"Random\", 4f, 0.25f, 10f) { rotationValue.get().equals(\"Intave\", true) }\r\n    private val turnSpeed = FloatRangeValue(\"TurnSpeed\", 180f, 180f, 0f, 180f, \"°\") {\r\n        !rotationValue.get().equals(\"None\", true)\r\n    }\r\n\r\n    private val priorityValue = ListValue(\"Priority\", arrayOf(\"Health\", \"Distance\", \"HurtResistance\", \"HurtTime\", \"Armor\"), \"Distance\")\r\n    val targetModeValue = ListValue(\"TargetMode\", arrayOf(\"Single\", \"Switch\", \"Multi\"), \"Switch\")\r\n    private val switchDelayValue = IntegerValue(\"SwitchDelay\", 1000, 1, 2000, \"ms\") {\r\n        targetModeValue.get().equals(\"switch\", true)\r\n    }\r\n    private val limitedMultiTargetsValue = IntegerValue(\"LimitedMultiTargets\", 1, 1, 50) {\r\n        targetModeValue.get().equals(\"multi\", true)\r\n    }\r\n\r\n    val swingValue = ListValue(\"Swing\", arrayOf(\"Normal\", \"Packet\", \"None\"), \"Normal\")\r\n    private val hitableCheckValue = BoolValue(\"HitableCheck\", false) { !rotationValue.get().equals(\"none\", true) && !throughWallsValue.get()}\r\n\r\n    val autoBlockModeValue: ListValue = object : ListValue(\"AutoBlock\", blockingModes.map { it.modeName }.toTypedArray(), \"None\") {\r\n        override fun onChange(oldValue: String, newValue: String) {\r\n            if (state) onDisable()\r\n        }\r\n\r\n        override fun onChanged(oldValue: String, newValue: String) {\r\n            if (state) onEnable()\r\n        }\r\n    }\r\n    private val interactValue = BoolValue(\"InteractAutoBlock\", true)\r\n    private val autoBlockRangeValue = FloatValue(\"AutoBlock-Range\", 5f, 0f, 12f, \"m\") {\r\n        !autoBlockModeValue.get().equals(\"None\", true)\r\n    }\r\n\r\n    private val raycastValue = BoolValue(\"RayCast\", true)\r\n    private val silentRotationValue = BoolValue(\"SilentRotation\", true) { !rotationValue.get().equals(\"none\", true) }\r\n    private val movementCorrection = ListValue(\"MovementCorrection\", arrayOf(\"None\", \"Normal\", \"Strict\"), \"Strict\")\r\n    private val predictValue = BoolValue(\"Predict\", true)\r\n    private val predictSize = FloatRangeValue(\"PredictSize\", 1f, 1f, 0.1f, 5f) {predictValue.get()}\r\n\r\n    private val espModes = ListValue(\"ESP\", arrayOf(\"Jello\", \"Off\"), \"Jello\")\r\n    private val circleValue = BoolValue(\"Circle\", true)\r\n    private val accuracyValue = IntegerValue(\"Accuracy\", 59, 0, 59) { circleValue.get() }\r\n    private val red = IntegerValue(\"Red\", 255, 0, 255) { circleValue.get() }\r\n    private val green = IntegerValue(\"Green\", 255, 0, 255) { circleValue.get() }\r\n    private val blue = IntegerValue(\"Blue\", 255, 0, 255) { circleValue.get() }\r\n    private val alpha = IntegerValue(\"Alpha\", 255, 0, 255) { circleValue.get() }\r\n\r\n    // Target\r\n    private val prevTargetEntities = mutableListOf<Int>()\r\n    private val discoveredEntities = mutableListOf<EntityLivingBase>()\r\n    private var lastMovingObjectPosition: MovingObjectPosition? = null\r\n    var target: EntityLivingBase? = null\r\n    var hitable = false\r\n\r\n    // Attack delay\r\n    private val attackTimer = MSTimer()\r\n    private var attackDelay = 0L\r\n    private var clicks = 0\r\n\r\n    // Fake block status\r\n    var blockingStatus = false\r\n\r\n    override fun onDisable() {\r\n        target = null\r\n        hitable = false\r\n        attackTimer.reset()\r\n        lastMovingObjectPosition = null\r\n        clicks = 0\r\n        prevTargetEntities.clear()\r\n        stopBlocking()\r\n        blockingMode.onDisable()\r\n    }\r\n\r\n    @EventTarget\r\n    fun onWorld(event: WorldEvent) {\r\n        lastMovingObjectPosition = null\r\n    }\r\n\r\n    @EventTarget\r\n    fun onUpdate(event: PreUpdateEvent){\r\n        blockingMode.onPreUpdate()\r\n\r\n        updateTarget()\r\n\r\n        target ?: run {\r\n            stopBlocking()\r\n            return\r\n        }\r\n\r\n        repeat (clicks) {\r\n            runAttack(it + 1 == clicks)\r\n            clicks--\r\n        }\r\n    }\r\n\r\n    @EventTarget\r\n    fun onRender3D(event: Render3DEvent) {\r\n        if (circleValue.get()) {\r\n            GL11.glPushMatrix()\r\n            GL11.glTranslated(\r\n                mc.thePlayer.lastTickPosX + (mc.thePlayer.posX - mc.thePlayer.lastTickPosX) * mc.timer.renderPartialTicks - mc.renderManager.renderPosX,\r\n                mc.thePlayer.lastTickPosY + (mc.thePlayer.posY - mc.thePlayer.lastTickPosY) * mc.timer.renderPartialTicks - mc.renderManager.renderPosY,\r\n                mc.thePlayer.lastTickPosZ + (mc.thePlayer.posZ - mc.thePlayer.lastTickPosZ) * mc.timer.renderPartialTicks - mc.renderManager.renderPosZ\r\n            )\r\n            GL11.glEnable(GL11.GL_BLEND)\r\n            GL11.glEnable(GL11.GL_LINE_SMOOTH)\r\n            GL11.glDisable(GL11.GL_TEXTURE_2D)\r\n            GL11.glDisable(GL11.GL_DEPTH_TEST)\r\n            GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)\r\n\r\n            GL11.glLineWidth(1F)\r\n            GL11.glColor4f(red.get().toFloat() / 255.0F, green.get().toFloat() / 255.0F, blue.get().toFloat() / 255.0F, alpha.get().toFloat() / 255.0F)\r\n            GL11.glRotatef(90F, 1F, 0F, 0F)\r\n            GL11.glBegin(GL11.GL_LINE_STRIP)\r\n\r\n            for (i in 0..360 step 60 - accuracyValue.get()) { // You can change circle accuracy  (60 - accuracy)\r\n                GL11.glVertex2f(cos(i * Math.PI / 180.0).toFloat() * rangeValue.get(), (sin(i * Math.PI / 180.0).toFloat() * rangeValue.get()))\r\n            }\r\n\r\n            GL11.glEnd()\r\n\r\n            GL11.glDisable(GL11.GL_BLEND)\r\n            GL11.glEnable(GL11.GL_TEXTURE_2D)\r\n            GL11.glEnable(GL11.GL_DEPTH_TEST)\r\n            GL11.glDisable(GL11.GL_LINE_SMOOTH)\r\n\r\n            GL11.glPopMatrix()\r\n        }\r\n\r\n        target ?: return\r\n\r\n        if (attackTimer.hasTimePassed(attackDelay) && target!!.hurtTime <= hurtTimeValue.get()) {\r\n            clicks++\r\n            attackTimer.reset()\r\n            attackDelay = RandomUtils.randomClickDelay(cps.getMinValue(), cps.getMaxValue())\r\n        }\r\n\r\n        /* Draw ESP */\r\n        when(espModes.get().lowercase()) {\r\n            \"jello\" -> drawCircle(target!!)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sigma Jello Mark\r\n     *\r\n     */\r\n    private fun drawCircle(it: EntityLivingBase) {\r\n        val drawTime = (System.currentTimeMillis() % 2000).toInt()\r\n        val drawMode=drawTime>1000\r\n        var drawPercent=drawTime/1000.0\r\n\r\n        if(!drawMode){\r\n            drawPercent = 1 -drawPercent\r\n        }else{\r\n            drawPercent-=1\r\n        }\r\n\r\n        drawPercent = if (drawPercent < 0.5) { 2 * drawPercent * drawPercent } else { 1 - (-2 * drawPercent + 2).pow(2) / 2 }\r\n        val points = mutableListOf<Vec3>()\r\n\r\n        val bb = it.entityBoundingBox\r\n        val radius = bb.maxX-bb.minX\r\n        val height = bb.maxY-bb.minY\r\n\r\n        val posX = it.lastTickPosX + (it.posX - it.lastTickPosX) * mc.timer.renderPartialTicks\r\n        var posY = it.lastTickPosY + (it.posY - it.lastTickPosY) * mc.timer.renderPartialTicks\r\n        if(drawMode){\r\n            posY -= 0.5\r\n        }else{\r\n            posY += 0.5\r\n        }\r\n        val posZ = it.lastTickPosZ + (it.posZ - it.lastTickPosZ) * mc.timer.renderPartialTicks\r\n\r\n        for(i in 0..360 step 7){\r\n            points.add(Vec3(posX - sin(i * Math.PI / 180F) * radius,posY+height*drawPercent,posZ + cos(i * Math.PI / 180F) * radius))\r\n        }\r\n        points.add(points[0])\r\n\r\n        mc.entityRenderer.disableLightmap()\r\n        GL11.glPushMatrix()\r\n        GL11.glDisable(GL11.GL_TEXTURE_2D)\r\n        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)\r\n        GL11.glEnable(GL11.GL_LINE_SMOOTH)\r\n        GL11.glEnable(GL11.GL_BLEND)\r\n        GL11.glDisable(GL11.GL_DEPTH_TEST)\r\n        GL11.glBegin(GL11.GL_LINE_STRIP)\r\n\r\n        val baseMove = (if (drawPercent > 0.5) 1-drawPercent else drawPercent) * 2\r\n        val min=(height/60)*20*(1-baseMove)*(if(drawMode) -1 else 1)\r\n\r\n        for(i in 0..20) {\r\n            var moveFace=(height/60F)*i*baseMove\r\n            if(drawMode){\r\n                moveFace=-moveFace\r\n            }\r\n            val firstPoint=points[0]\r\n            GL11.glVertex3d(\r\n                firstPoint.xCoord - mc.renderManager.viewerPosX, firstPoint.yCoord - moveFace - min - mc.renderManager.viewerPosY,\r\n                firstPoint.zCoord - mc.renderManager.viewerPosZ\r\n            )\r\n            GL11.glColor4f(1F, 1F, 1F, 0.7F*(i/20F))\r\n            for (vec3 in points) {\r\n                GL11.glVertex3d(\r\n                    vec3.xCoord - mc.renderManager.viewerPosX, vec3.yCoord - moveFace - min - mc.renderManager.viewerPosY,\r\n                    vec3.zCoord - mc.renderManager.viewerPosZ\r\n                )\r\n            }\r\n            GL11.glColor4f(0F,0F,0F,0F)\r\n        }\r\n        GL11.glEnd()\r\n        GL11.glEnable(GL11.GL_DEPTH_TEST)\r\n        GL11.glDisable(GL11.GL_LINE_SMOOTH)\r\n        GL11.glDisable(GL11.GL_BLEND)\r\n        GL11.glEnable(GL11.GL_TEXTURE_2D)\r\n        GL11.glPopMatrix()\r\n    }\r\n\r\n    /**\r\n     * Run attack with raycast check entity\r\n     * Author: CCBluex, fmcpe\r\n     * Refactor: toidicakhia\r\n     */\r\n\r\n    private fun runAttack(isLastClicks: Boolean) {\r\n        target ?: return\r\n\r\n        if (hitable) {\r\n            // Attack\r\n            if (!targetModeValue.get().equals(\"Multi\", true))\r\n                attackEntity(target!!)\r\n            else\r\n                discoveredEntities\r\n                    .filter { mc.thePlayer.getDistanceToEntityBox(it) < rangeValue.get() }\r\n                    .take(limitedMultiTargetsValue.get())\r\n                    .forEach(this::attackEntity)\r\n\r\n            prevTargetEntities.add(target!!.entityId)\r\n        } else runWithModifiedRaycastResult(rangeValue.get(), throughWallsRangeValue.get()) { obj ->\r\n            if (obj.typeOfHit != MovingObjectPosition.MovingObjectType.MISS)\r\n                return@runWithModifiedRaycastResult\r\n\r\n            lastMovingObjectPosition?.let {\r\n                if (it.typeOfHit == obj.typeOfHit)\r\n                    return@let\r\n\r\n                if (obj.typeOfHit == MovingObjectPosition.MovingObjectType.ENTITY) {\r\n                    val entity = obj.entityHit\r\n\r\n                    // Use own function instead of clickMouse() to maintain keep sprint, auto block, etc\r\n                    if (entity is EntityLivingBase && hitable) {\r\n                        attackEntity(entity)\r\n                        prevTargetEntities.add(target!!.entityId)\r\n                    }\r\n                } else mc.clickMouse()\r\n                lastMovingObjectPosition = obj\r\n            }\r\n\r\n            if (isLastClicks)\r\n                mc.sendClickBlockToController(false)\r\n        }\r\n\r\n        if (targetModeValue.get().equals(\"Switch\", true)) {\r\n            if (attackTimer.hasTimePassed(switchDelayValue.get().toLong())) {\r\n                prevTargetEntities.add(target!!.entityId)\r\n                attackTimer.reset()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun updateTarget() {\r\n        discoveredEntities.clear()\r\n\r\n        for (entity in mc.theWorld.loadedEntityList) {\r\n            if (entity !is EntityLivingBase || !isSelected(entity, true))\r\n                continue\r\n\r\n            if (targetModeValue.get().equals(\"switch\", true) && prevTargetEntities.contains(entity.entityId))\r\n                continue\r\n\r\n            if (mc.thePlayer.getDistanceToEntityBox(entity) <= rangeValue.get())\r\n                discoveredEntities.add(entity)\r\n        }\r\n\r\n        when (priorityValue.get().lowercase()) {\r\n            \"health\" -> discoveredEntities.sortBy { it.health + it.absorptionAmount }\r\n            \"hurtresistance\" -> discoveredEntities.sortBy { it.hurtResistantTime }\r\n            \"hurttime\" -> discoveredEntities.sortBy { it.hurtTime }\r\n            \"armor\" -> discoveredEntities.sortBy { it.totalArmorValue }\r\n            else -> discoveredEntities.sortBy { mc.thePlayer.getDistanceToEntityBox(it) }\r\n        }\r\n\r\n        discoveredEntities.forEach {\r\n            if (updateRotations(it))\r\n                return\r\n        }\r\n\r\n        /* If we couldn't find it, null here */\r\n        target = null\r\n\r\n        if (prevTargetEntities.isNotEmpty()) {\r\n            prevTargetEntities.clear()\r\n            updateTarget()\r\n        }\r\n    }\r\n\r\n    private fun updateRotations(entity: EntityLivingBase): Boolean {\r\n        val reach = min(rangeValue.get().toDouble(), mc.thePlayer.getDistanceToEntityBox(entity)) + 1\r\n\r\n        hitable = true\r\n        \r\n        if (rotationValue.get().equals(\"none\", true) || turnSpeed.getMaxValue() <= 0.0f)\r\n            return true\r\n\r\n        val rotation = RotationUtils.targetRotation ?: mc.thePlayer.rotation\r\n\r\n        val raycastEntity = RaycastUtils.raycastEntity(reach, rotation.yaw, rotation.pitch, object: RaycastUtils.IEntityFilter {\r\n            override fun canRaycast(entity: Entity?): Boolean {\r\n                return entity is EntityLivingBase && entity !is EntityArmorStand && isSelected(entity, true)\r\n            }\r\n        })\r\n\r\n        target = if (raycastValue.get() && raycastEntity == entity) {\r\n            raycastEntity as EntityLivingBase\r\n        } else entity\r\n\r\n        target?.let {\r\n            RotationUtils.setTargetRotation(\r\n                rotation = getTargetRotation(it) ?: return false,\r\n                keepLength = 0,\r\n                speed = RandomUtils.nextFloat(turnSpeed.getMinValue(), turnSpeed.getMaxValue()),\r\n                fixType = when (movementCorrection.get().lowercase()) {\r\n                    \"strict\" -> MovementCorrection.Type.STRICT\r\n                    \"normal\" -> MovementCorrection.Type.NORMAL\r\n                    else -> MovementCorrection.Type.NONE\r\n                },\r\n                silent = silentRotationValue.get()\r\n            )\r\n\r\n            hitable = mc.thePlayer.canEntityBeSeen(it)\r\n\r\n            if (throughWallsValue.get())\r\n                hitable = mc.thePlayer.getDistanceToEntityBox(it) < throughWallsRangeValue.get()\r\n\r\n            if (hitableCheckValue.get() && mc.objectMouseOver != null)\r\n                hitable = mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.ENTITY && RotationUtils.isFaced(it, reach)\r\n        } ?: return false\r\n\r\n        return true\r\n    }\r\n\r\n    private fun attackEntity(entity: EntityLivingBase) {\r\n        blockingMode.onPreAttack()\r\n\r\n        when (swingValue.get().lowercase()) {\r\n            \"normal\" -> mc.thePlayer.swingItem()\r\n            \"packet\" -> mc.netHandler.addToSendQueue(C0APacketAnimation())\r\n        }\r\n\r\n        mc.playerController.attackEntity(mc.thePlayer, entity)\r\n\r\n        if (interactValue.get()) {\r\n            mc.playerController.isPlayerRightClickingOnEntity(mc.thePlayer, mc.objectMouseOver.entityHit, mc.objectMouseOver)\r\n            mc.playerController.interactWithEntitySendPacket(mc.thePlayer, mc.objectMouseOver.entityHit)\r\n        }\r\n\r\n        blockingMode.onPostAttack()\r\n    }\r\n\r\n    private fun getTargetRotation(entity: Entity): Rotation? {\r\n        var boundingBox = entity.entityBoundingBox\r\n\r\n        if (predictValue.get() && !rotationValue.get().equals(\"Grim\", true) && !rotationValue.get().equals(\"Intave\", true)) {\r\n            boundingBox = boundingBox.offset(\r\n                (entity.posX - entity.prevPosX) * RandomUtils.nextFloat(predictSize.getMinValue(), predictSize.getMaxValue()),\r\n                (entity.posY - entity.prevPosY) * RandomUtils.nextFloat(predictSize.getMinValue(), predictSize.getMaxValue()),\r\n                (entity.posZ - entity.prevPosZ) * RandomUtils.nextFloat(predictSize.getMinValue(), predictSize.getMaxValue())\r\n            )\r\n        }\r\n\r\n        return when (rotationValue.get().lowercase()) {\r\n            \"vanilla\" -> {\r\n                val (_, rotation) = RotationUtils.searchCenter(\r\n                    boundingBox, false, predictValue.get(), throughWallsValue.get(), rangeValue.get()\r\n                ) ?: return null\r\n                rotation\r\n            }\r\n            \"backtrack\" -> RotationUtils.toRotation(RotationUtils.getCenter(entity.entityBoundingBox))\r\n            \"grim\" -> RotationUtils.toRotation(getNearestPointBB(mc.thePlayer.getPositionEyes(1F), boundingBox))\r\n            \"intave\" -> {\r\n                val rotation = RotationUtils.toRotation(\r\n                    Vec3(0.0, 0.0, 0.0),\r\n                    diff = Vec3(\r\n                        entity.posX - mc.thePlayer.posX,\r\n                        entity.posY + entity.eyeHeight * 0.9 - (mc.thePlayer.posY + mc.thePlayer.getEyeHeight()),\r\n                        entity.posZ - mc.thePlayer.posZ\r\n                    )\r\n                )\r\n                Rotation(\r\n                    rotation.yaw + Math.random().toFloat() * intaveRandomAmount.get() - intaveRandomAmount.get() / 2,\r\n                    rotation.pitch + Math.random().toFloat() * intaveRandomAmount.get() - intaveRandomAmount.get() / 2\r\n                )\r\n            }\r\n            else -> RotationUtils.serverRotation\r\n        }\r\n    }\r\n\r\n    fun startBlocking() {\r\n        if (canBlock && mc.thePlayer.getDistanceToEntityBox(target ?: return) <= autoBlockRangeValue.get()) {\r\n            mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(mc.thePlayer.inventory.getCurrentItem()))\r\n            blockingStatus = true\r\n        }\r\n    }\r\n\r\n    fun stopBlocking() {\r\n        if (blockingStatus) {\r\n            mc.netHandler.addToSendQueue(C07PacketPlayerDigging(C07PacketPlayerDigging.Action.RELEASE_USE_ITEM, BlockPos.ORIGIN, EnumFacing.DOWN))\r\n            blockingStatus = false\r\n        }\r\n    }\r\n\r\n    val canBlock: Boolean\r\n        get() = mc.thePlayer.heldItem != null && mc.thePlayer.heldItem.item is ItemSword\r\n\r\n    override val tag: String\r\n        get() = targetModeValue.get()\r\n\r\n    @EventTarget\r\n    fun onPreMotion(event: PreMotionEvent) {\r\n        blockingMode.onPreMotion()\r\n    }\r\n\r\n    @EventTarget\r\n    fun onPostMotion(event: PostMotionEvent) {\r\n        blockingMode.onPostMotion()\r\n    }\r\n\r\n    @EventTarget\r\n    fun onPacket(event: PacketEvent) {\r\n        blockingMode.onPacket(event)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/KillAura.kt b/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/KillAura.kt
--- a/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/KillAura.kt	(revision 4022216941ca602ce67b67ff810a4c882e1d8ede)
+++ b/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/KillAura.kt	(date 1715817963198)
@@ -81,7 +81,7 @@
         targetModeValue.get().equals("multi", true)
     }
 
-    val swingValue = ListValue("Swing", arrayOf("Normal", "Packet", "None"), "Normal")
+    private val swingValue = ListValue("Swing", arrayOf("Normal", "Packet", "None"), "Normal")
     private val hitableCheckValue = BoolValue("HitableCheck", false) { !rotationValue.get().equals("none", true) && !throughWallsValue.get()}
 
     val autoBlockModeValue: ListValue = object : ListValue("AutoBlock", blockingModes.map { it.modeName }.toTypedArray(), "None") {
Index: src/main/java/net/minusmc/minusbounce/features/module/modules/combat/LagReach.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package net.minusmc.minusbounce.features.module.modules.combat\r\n\r\nimport net.minecraft.client.entity.EntityOtherPlayerMP\r\nimport net.minecraft.entity.EntityLivingBase\r\nimport net.minecraft.network.Packet\r\nimport net.minecraft.network.play.client.*\r\nimport net.minecraft.network.play.server.*\r\nimport net.minecraft.network.play.INetHandlerPlayClient\r\nimport net.minecraft.world.WorldSettings\r\nimport net.minusmc.minusbounce.MinusBounce\r\nimport net.minusmc.minusbounce.event.*\r\nimport net.minusmc.minusbounce.features.module.Module\r\nimport net.minusmc.minusbounce.features.module.ModuleCategory\r\nimport net.minusmc.minusbounce.features.module.ModuleInfo\r\nimport net.minusmc.minusbounce.utils.BlinkUtils\r\nimport net.minusmc.minusbounce.utils.ClientUtils\r\nimport net.minusmc.minusbounce.utils.EntityUtils\r\nimport net.minusmc.minusbounce.utils.PacketUtils\r\nimport net.minusmc.minusbounce.utils.extensions.getDistanceToEntityBox\r\nimport net.minusmc.minusbounce.utils.timer.MSTimer\r\nimport net.minusmc.minusbounce.value.BoolValue\r\nimport net.minusmc.minusbounce.value.IntegerValue\r\nimport net.minusmc.minusbounce.value.ListValue\r\n\r\n@ModuleInfo(name = \"LagReach\", \"Lag Reach\", \"Very very lag\", ModuleCategory.COMBAT)\r\nclass LagReach : Module() {\r\n    private val modeValue = ListValue(\"Mode\", arrayOf(\"FakePlayer\", \"Intave\", \"IncomingBlink\"), \"IncomingBlink\")\r\n    private val pulseDelayValue = IntegerValue(\"Pulse\", 200, 50, 1000)\r\n    private val maxDelayValue = IntegerValue(\"Delay\", 500, 50, 2000)\r\n    private val spoof = BoolValue(\"Spoof\", false)\r\n    private val spoofDelay = IntegerValue(\"SpoofDelay\", 50, 0, 500) {spoof.get()}\r\n    private val incomingBlink = BoolValue(\"IncomingBlink\", true) { modeValue.get().equals(\"IncomingBlink\", true) }\r\n    private val velocityValue = BoolValue(\"PauseOnVelocity\", true) { modeValue.get().equals(\"IncomingBlink\", true) }\r\n    private val outgoingBlink = BoolValue(\"OutgoingBlink\", true) { modeValue.get().equals(\"IncomingBlink\", true) }\r\n    private val attackValue = BoolValue(\"ReleaseOnAttack\", true) { modeValue.get().equals(\"IncomingBlink\", true) }\r\n    private val intaveHurtTime = IntegerValue(\"Packets\", 5, 0, 30) { modeValue.get().equals(\"Intave\", true) }\r\n    private val aura = BoolValue(\"OnlyAura\", false)\r\n\r\n    private var fakePlayer: EntityOtherPlayerMP? = null\r\n    private val pulseTimer = MSTimer()\r\n    private val maxTimer = MSTimer()\r\n    private var currentTarget: EntityLivingBase? = null\r\n    private var shown = false\r\n\r\n    private val packets = mutableListOf<Packet<INetHandlerPlayClient>>()\r\n    private val times = ArrayList<Long>()\r\n\r\n    private var comboCounter = 0\r\n    private var backtrack = false\r\n\r\n    private var delay = 0L\r\n    private var targetDelay = 0L\r\n\r\n    override fun onEnable() {\r\n        if (spoof.get()) {\r\n            packets.clear()\r\n            times.clear()\r\n        }\r\n\r\n        backtrack = false\r\n\r\n        if (modeValue.get().equals(\"IncomingBlink\", true) && outgoingBlink.get())\r\n            BlinkUtils.setBlinkState(off = true, release = true)\r\n    }\r\n\r\n    override fun onDisable() {\r\n        removeFakePlayer()\r\n        clearPackets()\r\n\r\n        if (modeValue.get().equals(\"imcomingblink\", true) && outgoingBlink.get())\r\n            BlinkUtils.setBlinkState(off = true, release = true)\r\n\r\n        if (spoof.get()) {\r\n            packets.map {it}.forEach { PacketUtils.handlePacketNoEvent(it) }\r\n            packets.clear()\r\n            times.clear()\r\n        }\r\n    }\r\n\r\n    private fun removeFakePlayer() {\r\n        fakePlayer ?: return\r\n        currentTarget = null\r\n        mc.theWorld.removeEntity(fakePlayer)\r\n        fakePlayer = null\r\n    }\r\n\r\n    private fun clearPackets() {\r\n        packets.map {it}.forEach { PacketUtils.handlePacketNoEvent(it) }\r\n        packets.clear()\r\n\r\n        if (outgoingBlink.get()) {\r\n            BlinkUtils.releasePacket()\r\n            if (!backtrack) \r\n                BlinkUtils.setBlinkState(off = true, release = true)\r\n        }\r\n    }\r\n\r\n    @EventTarget\r\n    fun onAttack(event: AttackEvent) {\r\n        mc.theWorld ?: return\r\n\r\n        val target = event.targetEntity as EntityLivingBase\r\n        val targetId = target.uniqueID ?: return\r\n        val gameProfile = mc.netHandler.getPlayerInfo(targetId).gameProfile ?: return\r\n\r\n        comboCounter++\r\n        if (modeValue.get().equals(\"fakeplayer\", true) || modeValue.get().equals(\"intave\", true)) {\r\n            clearPackets()\r\n\r\n            if (fakePlayer == null) {\r\n                currentTarget = target\r\n\r\n                val faker = EntityOtherPlayerMP(mc.theWorld, gameProfile)\r\n                faker.rotationYawHead = target.rotationYawHead\r\n                faker.renderYawOffset = target.renderYawOffset\r\n                faker.copyLocationAndAnglesFrom(target)\r\n                faker.rotationYawHead = target.rotationYawHead\r\n                faker.health = target.health\r\n\r\n                for (idx in 0..4) {\r\n                    val equipmentInSlot = target.getEquipmentInSlot(idx) ?: continue\r\n                    faker.setCurrentItemOrArmor(idx, equipmentInSlot)\r\n                }\r\n\r\n                mc.theWorld.addEntityToWorld(-1337, faker)\r\n                fakePlayer = faker\r\n                shown = true\r\n            } else {\r\n                if (target == fakePlayer) {\r\n                    mc.playerController.attackEntity(mc.thePlayer, target)\r\n                    event.cancelEvent()\r\n                } else {\r\n                    fakePlayer = null\r\n                    currentTarget = target\r\n                    shown = false\r\n                }\r\n            }\r\n        } else {\r\n            if (target != currentTarget) {\r\n                clearPackets()\r\n                currentTarget = target\r\n            }\r\n\r\n            if (mc.thePlayer.getDistanceToEntityBox(target) > 2.6f && comboCounter >= 2) {\r\n                if (outgoingBlink.get()) \r\n                    BlinkUtils.setBlinkState(all = true)\r\n                backtrack = true\r\n                maxTimer.reset()\r\n            }\r\n\r\n            if (attackValue.get() && outgoingBlink.get())\r\n                BlinkUtils.releasePacket()\r\n\r\n        }\r\n\r\n        if (spoof.get() && mc.thePlayer.getDistanceToEntityBox(target) > 2.6) {\r\n            targetDelay = maxDelayValue.get().toLong()\r\n        }\r\n    }\r\n\r\n    @EventTarget\r\n    fun onUpdate(event: UpdateEvent) {\r\n\r\n        mc.thePlayer ?: return\r\n        mc.theWorld ?: return\r\n\r\n        if (!MinusBounce.combatManager.inCombat)\r\n            removeFakePlayer()\r\n\r\n\r\n        if (modeValue.get().equals(\"fakeplayer\", true) || modeValue.get().equals(\"intave\", true)) {\r\n            val killAura = MinusBounce.moduleManager[KillAura::class.java]\r\n\r\n            if (aura.get() && killAura != null && !killAura.state)\r\n                removeFakePlayer()\r\n\r\n            currentTarget?.let { current -> \r\n                fakePlayer?.let { currentFaker ->\r\n                    if (EntityUtils.isRendered(currentFaker) && (current.isDead || EntityUtils.isRendered(current)))\r\n                        removeFakePlayer()\r\n\r\n                    currentFaker.health = current.health\r\n                    for (idx in 0..4) {\r\n                        val equipmentInSlot = current.getEquipmentInSlot(idx) ?: continue\r\n                        currentFaker.setCurrentItemOrArmor(idx, equipmentInSlot)\r\n                    }\r\n\r\n                    when (modeValue.get().lowercase()) {\r\n                        \"intave\" -> if (mc.thePlayer.ticksExisted % intaveHurtTime.get() == 0) {\r\n                            currentFaker.rotationYawHead = current.rotationYawHead\r\n                            currentFaker.renderYawOffset = current.renderYawOffset\r\n                            currentFaker.copyLocationAndAnglesFrom(current)\r\n                            currentFaker.rotationYawHead = current.rotationYawHead\r\n                        }\r\n                        \"fakeplayer\" -> if (pulseTimer.hasTimePassed(pulseDelayValue.get())) {\r\n                            currentFaker.rotationYawHead = current.rotationYawHead\r\n                            currentFaker.renderYawOffset = current.renderYawOffset\r\n                            currentFaker.copyLocationAndAnglesFrom(current)\r\n                            currentFaker.rotationYawHead = current.rotationYawHead\r\n\r\n                            pulseTimer.reset()\r\n                        }\r\n                    }\r\n                } ?: return\r\n\r\n                val targetId = current.uniqueID ?: return\r\n                val playerInfo = mc.netHandler.getPlayerInfo(targetId) ?: return\r\n                val gameProfile = playerInfo.gameProfile ?: return\r\n\r\n                if (!shown) {\r\n                    val faker = EntityOtherPlayerMP(mc.theWorld, gameProfile)\r\n\r\n                    faker.rotationYawHead = current.rotationYawHead\r\n                    faker.renderYawOffset = current.renderYawOffset\r\n                    faker.copyLocationAndAnglesFrom(current)\r\n                    faker.rotationYawHead = current.rotationYawHead\r\n                    faker.health = faker.health\r\n\r\n                    for (idx in 0..4) {\r\n                        val equipmentInSlot = current.getEquipmentInSlot(idx) ?: continue\r\n                        faker.setCurrentItemOrArmor(idx, equipmentInSlot)\r\n                    }\r\n\r\n                    mc.theWorld.addEntityToWorld(-1337, faker)\r\n\r\n                    fakePlayer = faker\r\n                    shown = true\r\n                }\r\n\r\n            } ?: return\r\n\r\n        } else if (backtrack) {\r\n            if (pulseTimer.hasTimePassed(pulseDelayValue.get())) {\r\n                pulseTimer.reset()\r\n                clearPackets()\r\n            }\r\n            if (maxTimer.hasTimePassed(maxDelayValue.get())) {\r\n                clearPackets()\r\n                backtrack = false\r\n            }\r\n        }\r\n\r\n        if (spoof.get()) {\r\n            if (mc.thePlayer.ticksExisted < 20) {\r\n                times.clear()\r\n                packets.clear()\r\n            }\r\n\r\n            delay += (targetDelay - delay) / 3\r\n            targetDelay *= 93\r\n            targetDelay /= 100\r\n\r\n            if (packets.isEmpty()) \r\n                return\r\n\r\n            while (times.first() < System.currentTimeMillis() - delay) {\r\n                PacketUtils.handlePacketNoEvent(packets.removeFirst())\r\n                times.removeFirst()\r\n            }\r\n        }\r\n    }\r\n\r\n    @EventTarget\r\n    fun onPacket(event: PacketEvent) {\r\n        val packet = event.packet\r\n\r\n        val killAura = MinusBounce.moduleManager[KillAura::class.java]\r\n\r\n        if (aura.get() && (killAura != null && killAura.state) || !backtrack) {\r\n            clearPackets()\r\n            backtrack = false\r\n            return\r\n        }\r\n\r\n        if (modeValue.get().equals(\"incomingblink\") && packet.javaClass.name.contains(\"play.server.\", true) && backtrack) {\r\n            if (mc.thePlayer.ticksExisted < 20) \r\n                return\r\n\r\n            if (incomingBlink.get()) {\r\n\r\n                event.cancelEvent()\r\n                packets.add(packet as Packet<INetHandlerPlayClient>)\r\n\r\n                if (packet is S12PacketEntityVelocity && velocityValue.get()) {\r\n                    comboCounter = 0\r\n                    clearPackets()\r\n                    return\r\n                }\r\n            }\r\n        }\r\n\r\n        if (spoof.get() && packet.javaClass.name.contains(\"play.server.\", true) && mc.thePlayer.ticksExisted > 20 && targetDelay > 0) {\r\n            event.cancelEvent()\r\n            times.add(System.currentTimeMillis())\r\n            packets.add(packet as Packet<INetHandlerPlayClient>)\r\n\r\n            if (packet is S12PacketEntityVelocity) \r\n                targetDelay = spoofDelay.get().toLong()\r\n\r\n            if (packet is S08PacketPlayerPosLook) {\r\n                targetDelay = 0L\r\n\r\n                packets.map {it}.forEach { PacketUtils.handlePacketNoEvent(it) }\r\n                packets.clear()\r\n\r\n                times.clear()\r\n                return\r\n            }\r\n        }\r\n    }\r\n    \r\n    @EventTarget\r\n    fun onWorld(event: WorldEvent) {\r\n        if (spoof.get()) {\r\n            times.clear()\r\n            packets.clear()\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/LagReach.kt b/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/LagReach.kt
--- a/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/LagReach.kt	(revision 4022216941ca602ce67b67ff810a4c882e1d8ede)
+++ b/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/LagReach.kt	(date 1715817755586)
@@ -3,17 +3,15 @@
 import net.minecraft.client.entity.EntityOtherPlayerMP
 import net.minecraft.entity.EntityLivingBase
 import net.minecraft.network.Packet
-import net.minecraft.network.play.client.*
-import net.minecraft.network.play.server.*
 import net.minecraft.network.play.INetHandlerPlayClient
-import net.minecraft.world.WorldSettings
+import net.minecraft.network.play.server.S08PacketPlayerPosLook
+import net.minecraft.network.play.server.S12PacketEntityVelocity
 import net.minusmc.minusbounce.MinusBounce
 import net.minusmc.minusbounce.event.*
 import net.minusmc.minusbounce.features.module.Module
 import net.minusmc.minusbounce.features.module.ModuleCategory
 import net.minusmc.minusbounce.features.module.ModuleInfo
 import net.minusmc.minusbounce.utils.BlinkUtils
-import net.minusmc.minusbounce.utils.ClientUtils
 import net.minusmc.minusbounce.utils.EntityUtils
 import net.minusmc.minusbounce.utils.PacketUtils
 import net.minusmc.minusbounce.utils.extensions.getDistanceToEntityBox
@@ -272,7 +270,7 @@
             return
         }
 
-        if (modeValue.get().equals("incomingblink") && packet.javaClass.name.contains("play.server.", true) && backtrack) {
+        if (modeValue.get().equals("incomingblink", true) && packet.javaClass.name.contains("play.server.", true) && backtrack) {
             if (mc.thePlayer.ticksExisted < 20) 
                 return
 
Index: src/main/java/net/minusmc/minusbounce/features/module/modules/combat/BackTrack.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package net.minusmc.minusbounce.features.module.modules.combat\r\n\r\nimport net.minecraft.entity.Entity\r\nimport net.minecraft.entity.EntityLivingBase\r\nimport net.minecraft.entity.item.EntityArmorStand\r\nimport net.minecraft.entity.player.EntityPlayer\r\nimport net.minecraft.network.Packet\r\nimport net.minecraft.network.ThreadQuickExitException\r\nimport net.minecraft.network.play.INetHandlerPlayClient\r\nimport net.minecraft.network.play.client.C08PacketPlayerBlockPlacement\r\nimport net.minecraft.network.play.server.*\r\nimport net.minecraft.util.AxisAlignedBB\r\nimport net.minusmc.minusbounce.MinusBounce\r\nimport net.minusmc.minusbounce.event.*\r\nimport net.minusmc.minusbounce.features.module.Module\r\nimport net.minusmc.minusbounce.features.module.ModuleCategory\r\nimport net.minusmc.minusbounce.features.module.ModuleInfo\r\nimport net.minusmc.minusbounce.utils.EntityUtils\r\nimport net.minusmc.minusbounce.utils.PacketUtils\r\nimport net.minusmc.minusbounce.utils.extensions.*\r\nimport net.minusmc.minusbounce.utils.render.RenderUtils\r\nimport net.minusmc.minusbounce.utils.timer.MSTimer\r\nimport net.minusmc.minusbounce.value.BoolValue\r\nimport net.minusmc.minusbounce.value.IntegerValue\r\nimport net.minusmc.minusbounce.value.ListValue\r\nimport org.lwjgl.opengl.GL11\r\nimport org.lwjgl.opengl.GL11.*\r\nimport java.util.*\r\n\r\nimport java.lang.reflect.ParameterizedType\r\n\r\n@ModuleInfo(name = \"BackTrack\", spacedName = \"Back Track\", description = \"Let you attack in their previous position\", category = ModuleCategory.COMBAT)\r\nclass BackTrack : Module() {\r\n    private val modeValue = ListValue(\"TrackMode\", arrayOf(\"PacketDelay\", \"Automatic\", \"Manual\"), \"Automatic\")\r\n    private val esp = BoolValue(\"ESP\", true)\r\n    private val delayValue = IntegerValue(\"Delay\", 200, 0, 2000) { modeValue.get().equals(\"automatic\", true) }\r\n    private val onlyPlayer = BoolValue(\"OnlyƠlayer\", true) { modeValue.get().equals(\"automatic\", true) }\r\n    private val packetSize = IntegerValue(\"LimitPacketSize\", 100, 0, 1000) { modeValue.get().equals(\"packetdelay\", true) }\r\n\r\n    private var needFreeze = false\r\n    private val packets = mutableListOf<Packet<INetHandlerPlayClient>>()\r\n    private val storageEntities = mutableListOf<Entity>()\r\n\r\n    private var timer = MSTimer()\r\n    private var attacked: Entity? = null\r\n\r\n    private val packetEvents = LinkedList<PacketEvent>()\r\n    private val entities = hashMapOf<Int, BackTrackData>()\r\n\r\n    override fun onDisable() {\r\n        releasePackets()\r\n        clear()\r\n    }\r\n\r\n\r\n    @EventTarget\r\n    fun onUpdate(event: UpdateEvent) {\r\n        if (modeValue.get().equals(\"packetdelay\", true))\r\n            entities.forEach {_, entity -> entity.update()}\r\n    }\r\n\r\n    @EventTarget(priority = 1000)\r\n    fun onPacket(event: PacketEvent) {\r\n        mc.thePlayer ?: return\r\n        val packet = event.packet\r\n        \r\n        if (modeValue.get().equals(\"automatic\", true) || modeValue.get().equals(\"manual\", true)) {\r\n\r\n            if (!state)\r\n                return\r\n\r\n            if (packet.javaClass.name.contains(\"play.server.\", true)) {\r\n                if (packet is S14PacketEntity) {\r\n                    val entity = packet.getEntity(mc.theWorld)\r\n\r\n                    if (entity == null && entity !is EntityLivingBase || (onlyPlayer.get() && entity !is EntityPlayer)) \r\n                        return\r\n\r\n                    entity.serverPosX += packet.func_149062_c().toInt()\r\n                    entity.serverPosY += packet.func_149061_d().toInt()\r\n                    entity.serverPosZ += packet.func_149064_e().toInt()\r\n\r\n                    val x = entity.serverPosX.toDouble() / 32.0\r\n                    val y = entity.serverPosY.toDouble() / 32.0\r\n                    val z = entity.serverPosZ.toDouble() / 32.0\r\n                    if (EntityUtils.isSelected(entity, true)) {\r\n                        val afterBB = AxisAlignedBB(x - 0.4F, y - 0.1F, z - 0.4F, x + 0.4F, y + 1.9F, z + 0.4F)\r\n\r\n                        val eyes = mc.thePlayer.getPositionEyes(1F)\r\n                        val afterRange = getNearestPointBB(eyes, afterBB).distanceTo(eyes)\r\n                        val beforeRange = mc.thePlayer.getDistanceToEntityBox(entity)\r\n\r\n\r\n                        if (beforeRange <= 6) {\r\n                            if (afterRange > beforeRange + 0.02 && afterRange < 6f) {\r\n                                if (!needFreeze) {\r\n                                    timer.reset()\r\n                                    needFreeze = true\r\n                                }\r\n\r\n                                if (!storageEntities.contains(entity)) \r\n                                    storageEntities.add(entity)\r\n\r\n                                event.cancelEvent()\r\n                                return\r\n                            }\r\n                        } else if (modeValue.get().equals(\"automatic\", true) && afterRange < beforeRange && needFreeze) {\r\n                            releasePackets()\r\n                        }\r\n                    }\r\n\r\n                    if (needFreeze) {\r\n                        if (!storageEntities.contains(entity))\r\n                            storageEntities.add(entity)\r\n\r\n                        event.cancelEvent()\r\n                        return\r\n                    }\r\n\r\n                    if (!needFreeze) {\r\n                        MinusBounce.eventManager.callEvent(EntityMovementEvent(entity))\r\n                        val yaw = if (packet.func_149060_h()) packet.func_149066_f().toFloat() * 360 / 256.0f else entity.rotationYaw\r\n                        val pitch = if (packet.func_149060_h()) packet.func_149063_g().toFloat() * 360 / 256.0f else entity.rotationPitch\r\n                        entity.setPositionAndRotation2(x, y, z, yaw, pitch, 3, false)\r\n                        entity.onGround = packet.onGround\r\n                    }\r\n\r\n                    event.cancelEvent()\r\n                } else if (needFreeze) {\r\n                    if (packet is S19PacketEntityStatus && packet.opCode == 2.toByte())\r\n                        return\r\n\r\n                    packets.add(packet as Packet<INetHandlerPlayClient>)\r\n                    event.cancelEvent()\r\n                }\r\n            }\r\n        } else {\r\n            if (packet is S03PacketTimeUpdate)\r\n                return\r\n\r\n            if (packet is S01PacketJoinGame || packet is S07PacketRespawn) {\r\n                clear()\r\n                return\r\n            }\r\n\r\n            if (packet.javaClass.name.contains(\"play.server.\", true)) {\r\n                packetEvents.add(event)\r\n                event.cancelEvent()\r\n            }\r\n\r\n            if (packet is S0CPacketSpawnPlayer) {\r\n                if (entities[packet.entityID] == null)\r\n                    return\r\n                val backTrackData = BackTrackData()\r\n\r\n                backTrackData.x = packet.x\r\n                backTrackData.y = packet.y\r\n                backTrackData.z = packet.z\r\n                backTrackData.prevX = packet.z / 32.0\r\n                backTrackData.prevY = packet.y / 32.0\r\n                backTrackData.prevZ = packet.z / 32.0\r\n\r\n                entities[packet.entityID] = backTrackData\r\n            }\r\n\r\n            if (packet is S14PacketEntity) {\r\n                val entity = packet.getEntity(mc.theWorld) ?: return\r\n                val backTrackData = entities[entity.entityId] ?: run {\r\n                    if (entity is EntityArmorStand)\r\n                        return\r\n\r\n                    val entityBackTrackData = BackTrackData()\r\n                    entityBackTrackData.x = entity.serverPosX\r\n                    entityBackTrackData.y = entity.serverPosY\r\n                    entityBackTrackData.z = entity.serverPosZ\r\n\r\n                    val borderSize = entity.collisionBorderSize\r\n                    entityBackTrackData.width = entity.width / 2 + borderSize\r\n                    entityBackTrackData.height = entity.height + borderSize\r\n\r\n                    entityBackTrackData\r\n                }\r\n\r\n                entities[entity.entityId] = backTrackData\r\n                backTrackData.updateMotionX(packet.func_149062_c())\r\n                backTrackData.updateMotionY(packet.func_149061_d())\r\n                backTrackData.updateMotionZ(packet.func_149064_e())\r\n            }\r\n\r\n            if (packet is S18PacketEntityTeleport) {\r\n\r\n                val backTrackData = entities[packet.entityId] ?: run {\r\n                    val entity = mc.theWorld.getEntityByID(packet.entityId)\r\n                    val entityBackTrackData = BackTrackData()\r\n\r\n                    if (entity != null) {\r\n                        val borderSize = entity.collisionBorderSize\r\n                        entityBackTrackData.width = entity.width / 2 + borderSize\r\n                        entityBackTrackData.height = entity.height + borderSize\r\n                    }\r\n\r\n                    entityBackTrackData\r\n                }\r\n\r\n                backTrackData.x = packet.x\r\n                backTrackData.y = packet.y\r\n                backTrackData.z = packet.z\r\n\r\n                entities[packet.entityId] = backTrackData\r\n            }\r\n\r\n            if (packet is C08PacketPlayerBlockPlacement && packet.placedBlockDirection == 255)\r\n                return\r\n        }\r\n    }\r\n\r\n    private fun clear(size: Int) {\r\n        if (!modeValue.get().equals(\"packetdelay\", true))\r\n            return\r\n\r\n        while (packetEvents.size > size) {\r\n            val event = packetEvents.pollFirst() ?: continue\r\n            PacketUtils.handlePacketNoEvent(event.packet)\r\n        }\r\n    }\r\n\r\n    @EventTarget\r\n    fun onPostMotion(event: PostMotionEvent) {\r\n        mc.thePlayer ?: return\r\n\r\n        if (!modeValue.get().equals(\"packetdelay\", true)) {\r\n            clear(packetSize.get())\r\n            return\r\n        }\r\n\r\n        if (!needFreeze)\r\n            return\r\n\r\n        if (!modeValue.get().equals(\"manual\", true) && timer.hasTimePassed(delayValue.get())) {\r\n            releasePackets()\r\n            return\r\n        }\r\n\r\n        if (storageEntities.isEmpty())\r\n            return\r\n\r\n        var release = false\r\n        for (entity in storageEntities) {\r\n            val x = entity.serverPosX.toDouble() / 32.0\r\n            val y = entity.serverPosY.toDouble() / 32.0\r\n            val z = entity.serverPosZ.toDouble() / 32.0\r\n\r\n            val entityBB = AxisAlignedBB(x - 0.4F, y - 0.1F, z - 0.4F, x + 0.4F, y + 1.9F, z + 0.4F)\r\n            var range = entityBB.getLookingTargetRange(mc.thePlayer)\r\n\r\n            if (range == Double.MAX_VALUE) {\r\n                val eyes = mc.thePlayer.getPositionEyes(1F)\r\n                range = getNearestPointBB(eyes, entityBB).distanceTo(eyes) + 0.075\r\n            }\r\n\r\n            if (range <= 0.5) {\r\n                release = true\r\n                break\r\n            }\r\n\r\n            if (attacked != entity) \r\n                continue\r\n\r\n            if (!modeValue.get().equals(\"manual\", true) && timer.hasTimePassed(delayValue.get()) || range >= 6)\r\n                break\r\n        }\r\n\r\n        if (!modeValue.get().equals(\"manual\", true) && release)\r\n            releasePackets()\r\n    }\r\n\r\n    @EventTarget\r\n    fun onWorld(event: WorldEvent) {\r\n\r\n        if (modeValue.get().equals(\"packetdelay\", true)) {\r\n            clear()\r\n            return\r\n        }\r\n\r\n        attacked = null\r\n        storageEntities.clear()\r\n        event.worldClient ?: packets.clear()\r\n    }\r\n\r\n    @EventTarget\r\n    fun onRender3D(event: Render3DEvent) {\r\n        if (!esp.get())\r\n            return\r\n\r\n        GL11.glPushMatrix()\r\n        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)\r\n        glEnable(GL_BLEND)\r\n        glDisable(GL_TEXTURE_2D)\r\n        glDisable(GL_DEPTH_TEST)\r\n        glDepthMask(false)\r\n\r\n        // drawing\r\n        if (modeValue.get().equals(\"packetdelay\", true)) {\r\n            for (entity in entities.values) {\r\n                val target = MinusBounce.combatManager.target ?: continue\r\n\r\n                val px = entity.posX - mc.renderManager.renderPosX\r\n                val py = entity.posY - mc.renderManager.renderPosY\r\n                val pz = entity.posZ - mc.renderManager.renderPosZ\r\n\r\n                val bb = AxisAlignedBB(px - entity.width, py, pz - entity.width, px + entity.width, py + entity.height, pz + entity.width)\r\n                if (target.hurtTime > 0) \r\n                    RenderUtils.glColor(255, 32, 32, 35) \r\n                else \r\n                    RenderUtils.glColor(32, 255, 32, 35)\r\n\r\n                RenderUtils.drawFilledBox(bb)\r\n            }\r\n        } else for (entity in storageEntities) {\r\n            val x = entity.serverPosX / 32.0 - mc.renderManager.renderPosX\r\n            val y = entity.serverPosY / 32.0 - mc.renderManager.renderPosY\r\n            val z = entity.serverPosZ / 32.0 - mc.renderManager.renderPosZ\r\n\r\n            if (entity is EntityPlayer) {\r\n                if (entity.hurtTime > 0)\r\n                    RenderUtils.glColor(255, 32, 32, 35)\r\n                else \r\n                    RenderUtils.glColor(32, 255, 32, 35)\r\n\r\n                RenderUtils.drawFilledBox(AxisAlignedBB(x - 0.4F, y, z - 0.4F, x + 0.4F, y + 1.9F, z + 0.4F))\r\n            }\r\n        }\r\n\r\n        glColor4f(1.0f, 1.0f, 1.0f, 1.0f)\r\n        glDepthMask(true)\r\n        glDisable(GL_BLEND)\r\n        glEnable(GL_TEXTURE_2D)\r\n        glEnable(GL_DEPTH_TEST)\r\n        glPopMatrix()\r\n    }\r\n\r\n    private fun releasePackets() {\r\n        if (modeValue.get().equals(\"packetdelay\", true)) \r\n            return\r\n\r\n        attacked = null\r\n\r\n        if (packets.isEmpty())\r\n            return\r\n\r\n        packets.map {it}.forEach { \r\n            val event = PacketEvent(it)\r\n\r\n            if (!PacketUtils.packetList.contains(it))\r\n                MinusBounce.eventManager.callEvent(event)\r\n\r\n            if (!event.isCancelled)\r\n                it.processPacket(mc.netHandler)\r\n        }\r\n        packets.clear()\r\n\r\n        storageEntities.map {it}.forEach {\r\n            if (!it.isDead) {\r\n                val x = it.serverPosX.toDouble() / 32.0\r\n                val y = it.serverPosY.toDouble() / 32.0\r\n                val z = it.serverPosZ.toDouble() / 32.0\r\n                it.setPosition(x, y, z)\r\n            }\r\n        }\r\n        storageEntities.clear()\r\n\r\n        needFreeze = false\r\n    }\r\n\r\n    private fun clear() {\r\n        if (modeValue.get().equals(\"packetdelay\", true)) {\r\n            clear(0)\r\n            entities.clear()\r\n        }\r\n    }\r\n\r\n    override val tag: String\r\n        get() = modeValue.get()\r\n}\r\n\r\n\r\nprivate class BackTrackData {\r\n    var height = 1.9f\r\n    var width = 0.4f\r\n    var x = 0\r\n    var y = 0\r\n    var z = 0\r\n    var prevX = 0.0\r\n    var prevY = 0.0\r\n    var prevZ = 0.0\r\n    private var increment = 0\r\n\r\n    val posX: Double\r\n        get() = x / 32.0\r\n\r\n    val posY: Double\r\n        get() = y / 32.0\r\n\r\n    val posZ: Double\r\n        get() = z / 32.0\r\n\r\n    fun updateMotionX(xIncrement: Byte) {\r\n        prevX = posX\r\n        x += xIncrement\r\n        increment = 3\r\n    }\r\n\r\n    fun updateMotionY(yIncrement: Byte) {\r\n        prevY = posY\r\n        y += yIncrement\r\n        increment = 3\r\n    }\r\n\r\n    fun updateMotionZ(zIncrement: Byte) {\r\n        prevZ = posZ\r\n        z += zIncrement\r\n        increment = 3\r\n    }\r\n\r\n    fun update() {\r\n        if (increment > 0) {\r\n            prevX += ((x / 32.0) - prevX) / increment\r\n            prevY += ((y / 32.0) - prevY) / increment\r\n            prevZ += ((z / 32.0) - prevZ) / increment\r\n            --increment\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/BackTrack.kt b/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/BackTrack.kt
--- a/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/BackTrack.kt	(revision 4022216941ca602ce67b67ff810a4c882e1d8ede)
+++ b/src/main/java/net/minusmc/minusbounce/features/module/modules/combat/BackTrack.kt	(date 1715817945745)
@@ -1,11 +1,9 @@
 package net.minusmc.minusbounce.features.module.modules.combat
 
 import net.minecraft.entity.Entity
-import net.minecraft.entity.EntityLivingBase
 import net.minecraft.entity.item.EntityArmorStand
 import net.minecraft.entity.player.EntityPlayer
 import net.minecraft.network.Packet
-import net.minecraft.network.ThreadQuickExitException
 import net.minecraft.network.play.INetHandlerPlayClient
 import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement
 import net.minecraft.network.play.server.*
@@ -17,18 +15,17 @@
 import net.minusmc.minusbounce.features.module.ModuleInfo
 import net.minusmc.minusbounce.utils.EntityUtils
 import net.minusmc.minusbounce.utils.PacketUtils
-import net.minusmc.minusbounce.utils.extensions.*
+import net.minusmc.minusbounce.utils.extensions.getDistanceToEntityBox
+import net.minusmc.minusbounce.utils.extensions.getLookingTargetRange
+import net.minusmc.minusbounce.utils.extensions.getNearestPointBB
 import net.minusmc.minusbounce.utils.render.RenderUtils
 import net.minusmc.minusbounce.utils.timer.MSTimer
 import net.minusmc.minusbounce.value.BoolValue
 import net.minusmc.minusbounce.value.IntegerValue
 import net.minusmc.minusbounce.value.ListValue
-import org.lwjgl.opengl.GL11
 import org.lwjgl.opengl.GL11.*
 import java.util.*
 
-import java.lang.reflect.ParameterizedType
-
 @ModuleInfo(name = "BackTrack", spacedName = "Back Track", description = "Let you attack in their previous position", category = ModuleCategory.COMBAT)
 class BackTrack : Module() {
     private val modeValue = ListValue("TrackMode", arrayOf("PacketDelay", "Automatic", "Manual"), "Automatic")
@@ -56,7 +53,7 @@
     @EventTarget
     fun onUpdate(event: UpdateEvent) {
         if (modeValue.get().equals("packetdelay", true))
-            entities.forEach {_, entity -> entity.update()}
+            entities.forEach { (_, entity) -> entity.update()}
     }
 
     @EventTarget(priority = 1000)
@@ -73,7 +70,7 @@
                 if (packet is S14PacketEntity) {
                     val entity = packet.getEntity(mc.theWorld)
 
-                    if (entity == null && entity !is EntityLivingBase || (onlyPlayer.get() && entity !is EntityPlayer)) 
+                    if (entity == null || (onlyPlayer.get() && entity !is EntityPlayer))
                         return
 
                     entity.serverPosX += packet.func_149062_c().toInt()
@@ -117,13 +114,11 @@
                         return
                     }
 
-                    if (!needFreeze) {
-                        MinusBounce.eventManager.callEvent(EntityMovementEvent(entity))
-                        val yaw = if (packet.func_149060_h()) packet.func_149066_f().toFloat() * 360 / 256.0f else entity.rotationYaw
-                        val pitch = if (packet.func_149060_h()) packet.func_149063_g().toFloat() * 360 / 256.0f else entity.rotationPitch
-                        entity.setPositionAndRotation2(x, y, z, yaw, pitch, 3, false)
-                        entity.onGround = packet.onGround
-                    }
+                    MinusBounce.eventManager.callEvent(EntityMovementEvent(entity))
+                    val yaw = if (packet.func_149060_h()) packet.func_149066_f().toFloat() * 360 / 256.0f else entity.rotationYaw
+                    val pitch = if (packet.func_149060_h()) packet.func_149063_g().toFloat() * 360 / 256.0f else entity.rotationPitch
+                    entity.setPositionAndRotation2(x, y, z, yaw, pitch, 3, false)
+                    entity.onGround = packet.onGround
 
                     event.cancelEvent()
                 } else if (needFreeze) {
@@ -292,8 +287,8 @@
         if (!esp.get())
             return
 
-        GL11.glPushMatrix()
-        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
+        glPushMatrix()
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
         glEnable(GL_BLEND)
         glDisable(GL_TEXTURE_2D)
         glDisable(GL_DEPTH_TEST)
